个人博客 + RAG问答系统 —— 项目需求文档（PRD）
________________________________________
1. 项目背景与目标
本项目旨在构建一个极简风格的个人博客系统，支持作者以 Markdown 格式发布文章，并在此基础上集成 RAG（Retrieval-Augmented Generation）智能问答功能。
访客无需登录即可阅读所有文章，并可通过右下角对话入口，基于已发布的博客内容向 AI 提问（如：“作者有没有写过关于处理器的文章？”）。系统将结合博客文本生成有依据、可追溯的回答。
________________________________________
2. 用户角色
角色	访问方式	功能
访客（Visitor）	公开访问	浏览文章列表、阅读详情、使用 RAG 问答
python run.py
________________________________________
3. 前端设计
3.1 访客前端（Public Frontend）
•	技术栈：Vue 3 + Vite + Vue Router + Pinia（状态管理）
•	UI 风格：
o	极简、现代、极客风
o	主色调：黑色（背景）、紫色（按钮/链接）、绿色（代码块/高亮）
o	字体：等宽字体（如 JetBrains Mono）用于代码，无衬线字体用于正文
•	页面结构：
o	导航栏（固定顶部）：
	[文章] → 展示所有已发布博客（标题 + 摘要 + 时间）
	[关于] → 作者自我介绍（静态 Markdown 渲染）
o	文章列表页：卡片式布局，点击进入详情

o	文章详情页：
	完整渲染 Markdown（支持代码高亮、数学公式）
	左上角固定“返回”按钮（始终可见，不随滚动消失,点击返回文章列表）
o	RAG 对话入口：
	右下角悬浮圆形按钮
	点击展开聊天窗口，支持输入问题并显示 AI 回答
	初期支持单轮问答
3.2 管理员前端（Admin Panel）
•	技术栈：Flask + Jinja2（服务端渲染，非 SPA）
•	安全机制：
o	仅允许预设的 IP 地址白名单 访问 /admin/login
o	登录需验证 用户名 + 密码 存储于 .env
•	功能模块：
o	文章管理：
	表格展示所有文章（含状态：published/draft）
	支持创建、编辑（带 Markdown 预览）、删除、切换状态
o	访客记录：
	表格展示访问日志：IP、访问时间
	数据由后端自动记录（见 4.3 节）
________________________________________
4. 后端设计
4.1 技术栈
组件	技术选型
语言	Python 3.11
Web 框架	Flask
数据库	SQLite（结构化数据） + ChromaDB（向量数据库）
AI 服务	通义千问系列 API
4.2 AI 服务说明
服务	用途	输出/参数
Text-Embedding-v4	生成文本向量	向量维度：1024（float32）
Qwen 3-Rerank	对检索结果重排序	输入：query + candidates；输出：排序后的相关性分数
Qwen Plus	生成最终回答	支持长上下文，适合知识问答
所有 API 调用需通过环境变量配置 DASHSCOPE_API_KEY
4.3 API 设计原则
所有接口均为 POST 请求（便于传参和未来扩展）
接口路径统一前缀，如 /api/v1/...
4.4 核心数据流
A. 博客发布/更新流程（管理员操作触发）
1.	管理员提交 Markdown 博客（标题 + 内容）
2.	后端保存原始内容至 SQLite 表 posts
3.	调用 Markdown 分块函数（规则见 5.1 节），生成多个文本块（chunks）
4.	将每个 chunk 存入 SQLite 表 chunks（关联 post_id）
5.	对每个 chunk 调用 Text-Embedding-v4 API，获得 1024 维向量
6.	将 (chunk_id, embedding, metadata) 存入 ChromaDB（持久化到磁盘，collection 名：blog_chunks）
删除文章时，同步清理 chunks 表和 ChromaDB 中对应向量。
B. RAG 问答流程（访客提问触发）
1.	访客输入问题（如：“作者有没有写过关于处理器的文章？”）
2.	前端 POST 请求至 /api/v1/rag/query
3.	后端执行：
o	构造 系统提示词（System Prompt）：
“你是一个个人博客问答助手。请严格基于作者已发布的博客内容回答问题。若内容中无相关信息，请回答‘博客中未提及相关内容’。”
o	调用 Text-Embedding-v4 对用户问题生成 1024 维向量（临时使用，不存入数据库）
o	在 磁盘上的 ChromaDB 中执行相似度检索（top-k=10）
o	调用 Qwen 3-Rerank API 对 top-10 结果重排序，取 top-5
o	拼接 prompt：[系统提示] + [用户问题]+[top-5对应原文分块片段和post_id]
o	调用 Qwen Plus API 生成回答
4.	返回 JSON：{ "answer": "..." }，前端渲染
用户问题的向量仅用于本次检索，不持久化。ChromaDB 仅存储博客内容的向量。
________________________________________
5. 数据与处理细节
5.1 Markdown 分块策略
•	目标：保证语义完整性，避免截断关键信息
•	规则：
1.	按二级标题（##）分割大段落
2.	若某段落 > 512 tokens，则按句子边界进一步切分
3.	每个 chunk 附加元数据：post_id, title, chunk_index
5.2 向量维度说明
•	所有嵌入（embedding）均为 1024 维 float32 向量
•	ChromaDB 初始化时需指定 embedding_function=None（因使用外部 API）
•	存储时直接传入 embedding 列表（Python list of floats）
5.3 数据库设计（SQLite）
-- 博客文章
CREATE TABLE posts (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    title TEXT NOT NULL,
    content TEXT NOT NULL,        -- 原始 Markdown
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    status TEXT CHECK(status IN ('published', 'draft')) DEFAULT 'published'
);

-- 文本分块
CREATE TABLE chunks (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    post_id INTEGER NOT NULL,
    chunk_text TEXT NOT NULL,
    chunk_index INTEGER NOT NULL,
    FOREIGN KEY(post_id) REFERENCES posts(id) ON DELETE CASCADE
);

-- 访客访问日志
CREATE TABLE visits (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    ip TEXT NOT NULL,
    visited_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    path TEXT NOT NULL
);
5.4 ChromaDB 结构
•	Collection 名称：blog_chunks
•	每条记录包含：
o	id: 字符串格式 "chunk_{chunk_id}"
o	embedding: List[float]（长度 1024）
o	metadata: 
o	{
o	  "post_id": 123,
o	  "title": "深入理解CPU缓存",
o	  "chunk_text": "处理器中的L1缓存通常分为..."
o	}
________________________________________
6. 安全与性能考虑
事项	措施
错误处理	AI API 失败时返回友好提示，记录日志供调试
HTTPS	生产环境必须启用 HTTPS（防止密码/cookie 泄露）
________________________________________
7. 验收标准（MVP）
•	访客可浏览文章列表与详情
•	管理员可增删改博客，操作后自动更新向量库
•	访客可提问，系统基于博客内容生成回答
•	RAG 流程正确调用：Embedding → ChromaDB 检索 → Rerank → Qwen Plus 生成
•	所有向量维度为 1024，ChromaDB 正确持久化
•	UI 符合“黑+紫+绿”极客风格
